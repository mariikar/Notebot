# для метода котырый переименовывает файлы, некоторые библиотеки встроенны в руби, но он подгружает
# не все для быстрой работы и их необходимо звать вручную
require 'fileutils'

module PushNoteBot
  # Класс который занимается работой с файлами.
  class DataManager
    # Замораживаем наши константы строки. К стати КОНСТАНТЫ которые используются как переменные принято писать капсом
    # как раз чтобы не путать с именами классов, потому что это тоже константы, константы доступны во всем скоупе вызова.
    # То есть если бы я обьявил ее выше
    #
    # KONSTANT = 'data'
    #
    #   class Klass1
    #     KONSTANT доступна тут
    #   end
    #
    #   class Klass2
    #     KONSTANT  доступна тут
    #   end

    # и

    #   class Klass1
    #    KONSTANT = 'data'
    #    KONSTANT доступна тут
    #   end
    #
    #   class Klass2
    #     Klass1::KONSTANT  будет доступна только так (прописали ей полный адрес, иначе бы руби искал ее в классе Klass2
    #   end
    DEFAULT_NOTES_PATH = "#{__FILE__}/data/#{ENV['DEFAULT_NOTES_FILE']}".freeze

    attr_reader :default_notes_path

    # Здесь передаем по умолчанию DEFAULT_NOTES_PATH, такая запись хороша тем что если мы вызовем
    # DataManager.new без аргументов то в него передастся DEFAULT_NOTES_PATH, а если с
    # DataManager.new('./data/file.txt') то пойдет он, правда удобно? Это аттрибут по умолчанию, когда ты не уверена будешь ли
    # использовать какой то другой аттрибут кроме того по умолчанию. Лучше писать так, это более правильно.
    # Меньше будешь переписывать если что.
    def initialize(default_notes_path = DEFAULT_NOTES_PATH)
      @default_notes_path = default_notes_path
    end

    # Метод для получения стандартных записок, просто передаем путь и метод readlines (об этом ниже) и мемоизация.
    # Еще вернусь к ней. (мемоизации)
    def default_notes
      @default_notes ||= File.open(default_notes_path, &:readlines)
    end

    #     Делаем такой метод, для чтения юзерских записок. Открываем файл и передаем в блок метод :readlines
    #     &:readlines это короткая запись { |f| f.readlines }
    #     Помнишь,я говорил что если ты применяешь какой то метод на 1 аргумент то можно использовать такую запись через амперсанд
    #
    #     Так можно передавать методы в методы которые принимают блок такие как map, each File.open и много других
    #
    #       object.map(&:to_s)
    #
    #       File.open(file_path, &:readlines) Здесь аргумент &block идет вторым, поэтому передаем метод с амперсандом вторым.
    #
    #     Так руби делает обьект Proc, это такой блок который можно положить в переменную.
    #
    #     Создается он так
    #
    #        my_proc_with_attr = Proc.new { |attr1, attr2| и тут какой то код }
    #
    #        или
    #
    #        my_proc = proc { |attr| .... }
    #
    #        или
    #
    #        my_proc = Proc.new do
    #         ....
    #        end
    #
    #     Есть еще лямбды, то же самое что и прок, но между ними есть маленькая разница, если создать лямбду с аттрибутом,
    #     то вызвав её без аттрибута мы получим ошибку, с Proc такого не случится.
    #     Так же есть небольшая разница в том как они ведут себя внутри методов. Узнаешь позже)
    #
    #     Лямбду можно создать так:
    #
    #       my_lambda_without_attr = lambda { |attr| ... }
    #
    #       или
    #
    #       my_lambda = ->(attr) { ... } вот в этой записи аттрибут передается в скобочках после стрелки обозачающей лямбду.
    #
    #     То есть мы можем позвать Proc как my_proc.call(attr) и my_proc.call без аргумента ошибки не будет, бывает так что
    #     аргумент может не потребоваться (так написан код)
    #     Лямбду если создали с аргументом, то можем позвать только с ним. Вот и всё отличие.
    #
    #       my_lambda.call(attr)
    #       my_lambda_without_attr.call
    #
    #       и для Proc
    #
    #       my_proc_with_attr.call(attr1) можно передать 1 аргумент вместо двух, прок их не считает в отличие от лямбд
    #       my_proc_with_attr.call(attr1, attr2)
    #       my_proc_with_attr.call
    #
    #   По сути мы просто говорим руби  File.open(users_notes_file(id), Proc.new { |f| f.readlines} ) где f то что вернет
    #   File.open - обьект класса IO (input\output) к слову метод IO.open делает то же самое, просто File ребенок класса IO
    #   и наследует все его методы + свои, IO имеет более широкий функционал для работы с потоками ввода вывода.(забей)
    def notes_by_user(id)
      # вернем пустой массив если файла нет (потому что мы будем складывать их пожже с записями по умолчанию)
      return [] unless File.exist?(users_notes_file(id))

      File.open(users_notes_file(id), 'r', &:readlines)
    end

    # Тут ничего нового, передаем id в метод users_notes_file чтобы получить полный путь и вызываем c опцией 'a'
    # иначе каждая запись будет перетирать весь файл и мы будем иметь в нем только последнюю строчку ;)
    # По сути, опция 'w' - write, открыть файл для записи создает новый пустой файл.
    # id это просто идентификатор по которому надо узнавать юзера, это может быть и никнейм и внутренний id телеграма
    # File.open создаст файл если его нет, переживать за это не надо. Закрывать ничего не требуется потому что мы передаем
    # блок. Здесь укоротить как выше не удастся, потому что мы исползуем аттрибут строки для записи, а та запись не поддерживает передачу
    # аргументов внутрь вызываемого метода
    def write_users_note(id, note_string)
      File.open(users_notes_file(id), 'a') { |f| f.write(note_string) }
    end

    # C удалением все немного сложнее, мы не можем просто взять и удалить строчку из файла потому что они занимают какое то
    # продолжительное место в памяти (как стена из блоков лего), если мы хотим удалить какую то строку из памяти нам придется
    # перестроить как минимум все блоки после этой строки, т.е. следующая займет место предыдущей, следующая за ней этой, итп.
    # Поэтому мы поступим так. Откроем файл в режиме чтения и создадим такой же но с пометкой tmp - temporary - временный
    # Пройдемся по всем строкам нашего файла и перезапишем их во временный, кроме искомой строки, потом удалим обычный файл а
    # .tmp переименуем в обычный.
    def delete_users_note(id, note_string)
      # тут, чтобы не было ошибки вернем false если файла нет
      # return прервет работу метода
      return false unless File.exist?(users_notes_file(id))

      File.open(users_notes_file(id), 'r') do |file|
        File.open("#{users_notes_file(id)}.tmp", 'w') do |temp_file|
          # добавили .tmp --->            ^^^^
          # метод each_line грузит в память только 1 строку, т.е. файл находится не в памяти, к нему просто открыто соединение
          # поэтому IO называется поток, или stream
          file.each_line do |line|
            # пишем в новый файл строку, только если это не ту которую удаляем.
            # метод start_with? проверяет начинается ли с этих слов строка, это более безопасно потому
            # что в конце нашей строки будет символ новой строки, пришлось бы его удалять прежде чем сравнивать строки.
            temp_file.write(line) unless line.start_with? note_string
          end
        end
      end
      # Переименовываем. mv - от англ move, переместить, файл здесь не переименовывается, он копируется с новым именем и удаляется.
      # Всё, имеем новый файл с удаленной строкой.
      FileUtils.mv "#{users_notes_file(id)}.tmp", users_notes_file(id)
      # и вернем строку в случае успеха
      note_string
    end

    # Убираем кое какие методы в private потому что мы не будем их использовать извне класса, только внутри этого класса.
    private

    def users_notes_file(id)
      users_notes_file_path(id)
    end

    # Любимая (почти как ты) интеполяция, такая запись будет гораздо понятней чем
    #  __FILE__ + "/data/user_" + id.to_s + "_notes.txt"
    # согласись? :)
    def users_notes_file_path(id)
      "#{__FILE__}/data/user_#{id}_notes.txt"
    end
  end
end
